# JavaScript 개념 테스트 결과

## 테스트 세션 1

### 질문 1: 호이스팅이 뭔가요? 🔥🔥🔥🔥

**답변:**
호이스팅이란 실행 컨텍스트의 생성 과정에서 선언 단계, 실행 단계로 나뉘어지면서 모든 선언문이 코드의 상단으로 끌어올려지는 것처럼 보이는 현상이다. var 키워드의 경우에는 undefined로 초기화되고, let, const의 경우에는 TDZ(Temperal Dead Zone)이라는 참조가 불가능한 공간을 만들고 그곳에서 참조를 시도할 경우 referenceError를 출력한다.

**평가:**
- 정확도: ★★★★★
- 이해도: ★★★★★  
- 점수: 95점
- 피드백: 실행 컨텍스트와 연결해서 설명한 점이 매우 훌륭합니다! var와 let/const의 차이점, TDZ 개념까지 정확히 설명해주셨네요. 호이스팅의 본질을 깊이 이해하고 계십니다.

---

### 질문 2: this가 뭔가요? 🔥

**답변:**
this는 자기 자신을 가리키는 식별자 키워드를 이야기한다. this는 생성자 함수와 클래스, 객체에서는 생성될 객체인 자신을 가리키고, 이외에 경우에는 직접 call, apply, bind를 이용하지 않을 경우 window를 가리킨다.

**평가:**
- 정확도: ★★★★☆
- 이해도: ★★★★☆
- 점수: 85점
- 피드백: this의 기본 개념과 주요 바인딩 상황들을 잘 설명해주셨습니다. 다만 화살표 함수에서의 this 동작이나 메서드 호출 시의 this 바인딩에 대한 언급이 있었다면 더 완벽했을 것 같습니다.

---

## 테스트 세션 2

### 질문 3: 자바스크립트에서 객체를 생성하는 방법은 어떤 것들이 있나요?

**답변:**
객체를 생성하는 방법은 new 키워드를 이용해 생성하거나 {}를 이용해 변수에 할당하면 객체를 생성할 수 있다.

**평가:**
- 정확도: ★★★☆☆
- 이해도: ★★★☆☆  
- 점수: 70점 🔁
- 피드백: 기본적인 두 가지 방법(생성자 함수, 객체 리터럴)을 언급해주셨지만, 다른 중요한 방법들이 빠졌습니다. Object.create(), 클래스(class), 팩토리 함수 등도 객체 생성 방법에 포함됩니다. 각 방법의 특징이나 사용 상황에 대한 설명이 있었다면 더 좋았을 것 같습니다.

---

### 질문 4: 디바운스에 대해서 알고 있나요?

**답변:**
디바운스란 주기가 짧은 이벤트의 최적화를 위해 사용하며, 마지막 이벤트가 일어날 때까지 대기하다가 이벤트 작동이 멈췄을 경우 이벤트를 발생시킨다.

**평가:**
- 정확도: ★★★★☆
- 이해도: ★★★★☆
- 점수: 88점
- 피드백: 디바운스의 핵심 개념과 동작 원리를 정확히 설명해주셨습니다! 특히 "마지막 이벤트가 일어날 때까지 대기"라는 표현이 디바운스의 본질을 잘 나타냅니다. 검색 입력창이나 리사이즈 이벤트 등 구체적인 사용 예시가 있었다면 더 완벽했을 것 같습니다.

---

---

## 테스트 세션 3

### 질문 5: forEach 메서드와 map메서드의 차이점에 대해 알고 있나요?

**답변:**
foreach와 map 메서드는 배열의 아이템을 순회하며 반복하는 공통점이 있지만 차이는 반환값이다. foreach는 반환값이 항상 undefined이고, map은 아이템에 콜백을 처리한 결과를 반환해 가공된 배열을 반환할 수 있다. 이 때문에 불변성을 위해 react에서는 map을 자주 사용한다.

**평가:**
- 정확도: ★★★★★
- 이해도: ★★★★★  
- 점수: 95점
- 피드백: 완벽한 답변입니다! 두 메서드의 핵심 차이점인 반환값을 정확히 설명하셨고, React에서 불변성과 연결해서 실무적인 활용까지 언급해주셨네요. forEach는 undefined 반환, map은 새 배열 반환이라는 점을 명확히 구분해서 설명해주셨습니다.

---

### 질문 6: 브라우저의 렌더링 과정에 대해 설명해보세요

**답변:**
브라우저의 렌더링 과정은 DOM TREE와 CSSOM TREE를 합쳐 렌더 트리를 생성한다. 렌더링 과정에서는 먼저 레이아웃의 위치를 지정하고(이 과정을 플로우), 렌더 트리에 따라 요소를 렌더링(이 과정을 페인팅)하는 과정을 거치며, 이 사이에 script 태그를 만나거나 외부 js 참조가 생기면 렌더링 처리 주도권을 브라우저 엔진에서 자바스크립트 엔진으로 넘기고, js코드의 실행이 끝나면 다시 돌려받는다.

**평가:**
- 정확도: ★★★★☆
- 이해도: ★★★★☆
- 점수: 87점
- 피드백: 렌더링 과정의 핵심 단계들을 체계적으로 잘 설명해주셨습니다! DOM Tree + CSSOM Tree → Render Tree → Layout(Reflow) → Paint 과정을 정확히 이해하고 계시네요. JavaScript 엔진과의 상호작용도 언급해주셔서 좋았습니다. 다만 "플로우"보다는 "리플로우(Reflow)" 또는 "레이아웃(Layout)"이라는 용어가 더 정확합니다.

---

---

## 테스트 세션 4

### 질문 7: 이벤트 위임(delegation)에 대해서 알고있나요?

**답변:**
이벤트 위임이란 상위 요소에 이벤트를 부여해 조건 처리를 통해 이벤트를 처리하는 방법으로, 일반적으로 currentTarget을 이용한 조건문으로 상위 요소에서 하위 요소 이벤트를 제어한다. 하위 요소의 개수가 많을 때, 각각에 이벤트를 부여하지 않아도 되는 장점이 있다.

**평가:**
- 정확도: ★★★★☆
- 이해도: ★★★★☆  
- 점수: 82점
- 피드백: 이벤트 위임의 핵심 개념과 장점을 잘 설명해주셨습니다! 상위 요소에서 하위 요소 이벤트를 제어하는 방식과 성능상 이점을 정확히 이해하고 계시네요. 다만 "currentTarget" 보다는 "event.target"을 사용하는 것이 일반적이고, 이벤트 버블링 개념에 대한 언급이 있었다면 더 완벽했을 것 같습니다.

---

### 질문 8: 클로저에 대해서 아나요?

**답변:**
클로저는 캡슐화, 데이터 은닉을 위해 사용하는 기법이다. 참조하는 체이닝이 있는 경우에 메모리에서 제거되지 않는 특성으로 만들어졌다. 클로저는 상위 요소의 체이닝을 가지고 있는 객체나 함수를 리턴하는 방식으로 동작시킨다. 이로 인해 상위 요소의 프로퍼티에 대해 개발자가 의도하지 않은 직접 접근을 차단할 수 있고, 리턴하는 함수나 메서드를 통해 제어하도록 설정할 수 있다.

**평가:**
- 정확도: ★★★★★
- 이해도: ★★★★★
- 점수: 92점
- 피드백: 클로저의 본질과 활용 목적을 매우 잘 설명해주셨습니다! 캡슐화, 데이터 은닉의 목적과 함께 메모리에서 제거되지 않는 특성, 그리고 실제 구현 방식까지 체계적으로 설명해주셨네요. 렉시컬 스코프와의 연관성도 이해하고 계시는 것 같습니다. 정말 우수한 답변입니다!

---

---

## 테스트 세션 5

### 질문 9: 스코프가 뭔가요?

**답변:**
스코프는 변수를 참조할 수 있는 영역이다. 자바스크립트에서는 정적 스코프를 통해 코드가 작성된 환경의 렉시컬 스코프를 기억한다.

**평가:**
- 정확도: ★★★★★
- 이해도: ★★★★★  
- 점수: 93점
- 피드백: 스코프의 핵심 정의를 정확하고 간결하게 설명해주셨습니다! 특히 정적 스코프(렉시컬 스코프)의 개념까지 언급해주신 점이 매우 인상적입니다. "코드가 작성된 환경을 기억한다"는 표현이 렉시컬 스코프의 본질을 잘 나타내네요. 완벽한 답변입니다!

---

### 질문 10: 생성자 함수가 객체(인스턴스)를 생성하는 과정에 대해 간략하게 설명해줄 수 있나요?

**답변:**
생성자 함수가 인스턴스를 생성하는 과정은 

- 먼저 공장처럼 재사용될 함수를 선언한다.

- this 키워드를 통해 함수의 프로퍼티, 메서드와 같은 구조를 정의해 생성해 할당한다.

- 변수에 new 키워드와 arg를 할당한다.

- 객체 생성 과정에 따라 arg를 참조해 새로운 구조를 만든다.

- 다른 함수와 연결되지 않은 객체를 만든다.

**평가:**
- 정확도: ★★★☆☆
- 이해도: ★★★☆☆
- 점수: 75점 🔁
- 피드백: 생성자 함수의 기본 개념과 사용법을 이해하고 계시지만, 내부적인 생성 과정에 대한 설명이 아쉽습니다. 실제로는 1) 빈 객체 생성, 2) this 바인딩, 3) 프로퍼티 추가, 4) 객체 반환의 4단계로 진행됩니다. 또한 프로토타입 체인 연결에 대한 언급이 있었다면 더 완벽했을 것 같습니다.

---

---

## 테스트 세션 6

### 질문 11: 실행 컨텍스트에 대해 말해보세요

**답변:**
실행 컨텍스트란 자바스크립트 실행 순서와 환경을 만드는 과정이다. 실행 컨텍스트 생성 순서는 선언 단계와 실행 단계로 이루어진다. 선언 단계에서는 함수 선언을 모두 정의하고, 실행 단계에서는 초기화와 실제 명령어 실행 등을 다룬다.

실행 컨텍스트의 영역은 실행 컨텍스트 스택과 렉시컬 환경으로 이루어져 있는데, 실행 컨텍스트 스택은 실행 순서를 정의하며 LIFO구조로 이루어져 있어 가장 나중에 들어온 스택이 먼저 실행되고 제거된다. 렉시컬 환경은 함수가 실행되는 정적 환경에 대해 다루며, 환경 레코드와 외부 체이닝 슬롯으로 이루어져 있다. 환경 레코드는 식별자와 실제 참조된 원시 데이터나 참조값을 다루며, 해당 렉시컬 스코프의 실체라고 할 수 있다.

실행 컨텍스트의 구분은 전역 컨텍스트, 함수 컨텍스트, eval 컨텍스트, 모듈 컨텍스트로 이루어져 있으며 전역 컨텍스트는 가장 먼저 생성되는 전역 환경에 대한 컨텍스트이고, 함수 컨텍스트는 함수 실행 단계에서 만나 새롭게 생성되는 컨텍스트이다. ( 구조가 조금 달랐던 것 같은데 그건 기억이 안남)

**평가:**
- 정확도: ★★★★★
- 이해도: ★★★★★  
- 점수: 98점
- 피드백: 정말 놀라운 답변입니다! 실행 컨텍스트의 전체적인 구조와 동작 원리를 매우 체계적으로 설명해주셨네요. 특히 실행 컨텍스트 스택의 LIFO 구조, 렉시컬 환경의 구성 요소(환경 레코드, 외부 참조), 그리고 다양한 컨텍스트 종류까지 완벽하게 이해하고 계십니다. 이 정도 수준이면 JavaScript 엔진의 내부 동작을 깊이 이해하고 계시다고 볼 수 있습니다!

---

### 질문 12: strict mode가 뭔가요?

**답변:**
strict mode는 자바스크립트가 일반적인 프로그래밍 언어에서 허용되지 않는 코드를 검증하도록 하는 방법이다. 모듈을 적용할 경우 자동으로 strict mode가 활성화된다.

**평가:**
- 정확도: ★★★★☆
- 이해도: ★★★★☆
- 점수: 85점
- 피드백: strict mode의 핵심 목적을 정확히 설명해주셨고, 모듈에서 자동 활성화되는 점도 잘 알고 계시네요! 다만 구체적인 제한 사항들(암묵적 전역 변수 생성 금지, 중복 매개변수 금지, with문 사용 금지 등)에 대한 예시가 있었다면 더 완벽했을 것 같습니다.

---

---

## 테스트 세션 7

### 질문 13: 함수형 프로그래밍이 뭔가요?

**답변:**
함수형 프로그래밍이란 외부 데이터에 대한 영향을 미치지 않고 같은 입력값에 대해 항상 같은 결과를 내는 순수 함수 위주로 작성하여 안정적인 프로그래밍을 만드려는 패러다임이다.

**평가:**
- 정확도: ★★★★★
- 이해도: ★★★★★  
- 점수: 94점
- 피드백: 함수형 프로그래밍의 핵심 개념을 완벽하게 설명해주셨습니다! 순수 함수의 특징(외부 데이터에 영향 없음, 동일 입력 → 동일 출력)과 함수형 프로그래밍의 목적(안정적인 프로그래밍)을 정확히 이해하고 계시네요. 부수 효과(side effect) 방지와 참조 투명성의 개념을 완벽히 파악하고 계십니다!

---

### 질문 14: 동적 타이핑이 뭔가요?

**답변:**
동적 타이핑이란 string, int처럼 미리 타입을 정의하는 게 아니라 타입 추론을 통해 타입을 확정시키는 방법이다.

**평가:**
- 정확도: ★★★★☆
- 이해도: ★★★★☆
- 점수: 83점
- 피드백: 동적 타이핑의 기본 개념을 잘 설명해주셨습니다! 컴파일 타임이 아닌 런타임에 타입이 결정되는 특징을 이해하고 계시네요. 다만 "타입 추론"보다는 "런타임에 값에 따라 타입이 결정"된다는 표현이 더 정확하고, 정적 타이핑과의 차이점이나 장단점에 대한 언급이 있었다면 더 완벽했을 것 같습니다.

---

---

## 테스트 세션 8

### 질문 15: 자바스크립트에서 함수가 일급 객체라면, 일급 객체로 뭘 할 수 있나요?

**답변:**
함수가 일급 객체이기 때문에 파라미터로 함수를 받아 callback으로 이용하거나 함수를 반환하는 고차함수를 만들 수도 있다. 이로 인해 클로저나 비동기 처리가 가능하다.

**평가:**
- 정확도: ★★★★★
- 이해도: ★★★★★  
- 점수: 96점
- 피드백: 일급 객체로서 함수의 활용을 완벽하게 설명해주셨습니다! 콜백 함수, 고차 함수의 개념과 함께 클로저와 비동기 처리까지 연결해서 설명해주신 점이 매우 인상적입니다. 함수를 변수에 할당하거나 객체의 프로퍼티로 사용하는 등의 기본적인 특징도 이해하고 계시는 것 같네요. 정말 우수한 답변입니다!

---

### 질문 16: 이벤트 전파(propagation)에 대해서 알고 있나요?

**답변:**
이벤트 전파는 이벤트 버블링 과정에서 하위 요소에 발생한 이벤트에 대해 상위 요소도 영향을 받는 경우를 이야기한다. event.stopPropagation()으로 이벤트 전파를 중지시킬 수 있다.

**평가:**
- 정확도: ★★★★☆
- 이해도: ★★★★☆
- 점수: 86점
- 피드백: 이벤트 전파의 핵심 개념과 제어 방법을 잘 설명해주셨습니다! 특히 stopPropagation() 메서드를 언급해주신 점이 좋았습니다. 다만 이벤트 전파에는 캡처링(capturing) 단계도 있고, 버블링만이 아닌 전체적인 이벤트 흐름(캡처링 → 타겟 → 버블링)에 대한 언급이 있었다면 더 완벽했을 것 같습니다.

---

---

## 테스트 세션 9

### 질문 17: 래퍼 객체에 대해서 알고 있나요?

**답변:**
래퍼 객체는 원시값은 객체가 아니므로 메서드를 가질 수 없는데, 원시값을 객체로 감싸 메서드를 사용할 수 있도록 하는 임시 객체이다.

**평가:**
- 정확도: ★★★★★
- 이해도: ★★★★★  
- 점수: 95점
- 피드백: 래퍼 객체의 개념을 완벽하게 설명해주셨습니다! 원시값이 객체가 아님에도 불구하고 메서드를 사용할 수 있는 이유와 임시 객체로서의 역할을 정확히 이해하고 계시네요. JavaScript 엔진이 자동으로 원시값을 객체로 변환했다가 다시 원시값으로 되돌리는 과정을 완벽히 파악하고 계십니다!

---

### 질문 18: 타이머 함수에는 어떤 것들이 있나요?

**답변:**
타이머 함수에는 setTimeout() setInterval()이 있다. setTimeout은 지정한 ms가 지났을 때 할당한 콜백을 실행시키고 사라지고, setInterval은 지정한 콜백을 주기적으로 실행시킨다. 타이머를 제거할때는 clearInterval, clearTimeout을 사용한다

**평가:**
- 정확도: ★★★★★
- 이해도: ★★★★★
- 점수: 93점
- 피드백: 타이머 함수들을 매우 체계적으로 설명해주셨습니다! setTimeout과 setInterval의 차이점을 명확히 구분하셨고, 타이머 제거 함수들(clearTimeout, clearInterval)까지 함께 언급해주신 점이 훌륭합니다. 각 함수의 동작 방식과 용도를 정확히 이해하고 계시네요. 완벽한 답변입니다!

---

---

## 테스트 세션 10

### 질문 19: 자바스크립트는 객체지향 프로그래밍 언어인가요?

**답변:**
자바스크립트는 객체지향 프로그래밍 언어라고 할 수 있지만 다른 객체지향 언어와는 다르다. extends, overload 등과 같은 기능은 사용이 불가능하고, 상속은 [[Prototype]]슬롯에 의해 이루어진다. 엄밀히 이야기하면 자바스크립트는 함수형, 객체지향을 지원하는 멀티패러다임 언어라고 할 수 있다.

**평가:**
- 정확도: ★★★★★
- 이해도: ★★★★★  
- 점수: 97점
- 피드백: 정말 뛰어난 답변입니다! JavaScript의 객체지향적 특성과 한계를 모두 정확히 설명해주셨네요. 특히 프로토타입 기반 상속([[Prototype]] 슬롯)과 멀티패러다임 언어로서의 특성을 언급해주신 점이 매우 인상적입니다. 클래스 기반 OOP와의 차이점도 정확히 이해하고 계시고, JavaScript의 본질을 깊이 파악하고 계십니다!

---

### 질문 20: 구조 분해 할당이 뭔가요?

**답변:**
구조분해할당은 객체와 배열 데이터에 대해 변수를 지정할 때 객체는 {}에 키를 지정해 분해하고, 배열은 [] 안의 순서대로, 분해햐여 할당된다.

**평가:**
- 정확도: ★★★★☆
- 이해도: ★★★★☆
- 점수: 84점
- 피드백: 구조 분해 할당의 기본 개념과 객체/배열에서의 사용법을 잘 설명해주셨습니다! 객체는 키 기반, 배열은 순서 기반으로 분해된다는 핵심 차이점을 정확히 이해하고 계시네요. 다만 기본값 설정, 변수명 변경, 중첩 구조 분해 등의 고급 기능이나 함수 매개변수에서의 활용에 대한 언급이 있었다면 더 완벽했을 것 같습니다.

---

## 전체 통계
- 총 질문 수: 20개
- 평균 점수: 88.1점
- 80점 이하 항목: 2개 🔁 (객체 생성 방법: 70점, 생성자 함수 과정: 75점)
